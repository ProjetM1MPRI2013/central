/**
 * @author: Adrien H.
 */
#ifndef EVENT_LISTENER_H
#define EVENT_LISTENER_H

#include "withUuid.h"
#include "eventManager.h"
#include <type_traits>

/**
 * @brief EventListeners may listen to events generated by the Simulation
 *
 * How to use:
 *
 * Derive it like so :
 *
 *   class MyClass : public EventListener<MyClass>
 *
 * (see technical reasons below)
 *
 * To listen to an event from a source, say:
 *
 *   listen("myEvent", mySource, myCallback);
 *
 * where mySource derives EventSource
 * and myCallback is some qualified member method, for instance &MyClass::myCallback
 */

// Make parent (EventListener) class aware of any of its subclasses. 
// The only purpose of this is to free the programmer from having to write:
// listen(this, S source, [] { ... callback ... })
// instead, they can just write:
// listen(S source, [] { ... callback ... })
// You must inherit from EventManager like so : class MyClass : EventManager<MyClass> { ... }
// otherwise, some totally unsafe casts will happen.
template <class Child>
class EventListener : public GenericEventListener {

public :

    EventListener();
    EventListener(boost::uuids::uuid uuid);

    /**
     * @brief listen to events of type eventT on source using callback
     * @param eventT: type of event being listened to (can be empty)
     * @param source: object the event is about
     * @param callback: a method of the instance inheriting from EventListener 
    */
    // Give a callback which takes arguments by reference
    template <typename SourceT, typename ArgT>
    void listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&, ArgT&));
    // Give a callback which takes arguments by value
    template <typename SourceT, typename ArgT>
    void listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&, ArgT));
    // Give a callback which takes no arguments
    template <typename SourceT>
    void listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&));

    /**
     * @brief unlisten to events of type eventT on source
     */
    template <typename SourceT>
    void unlisten(EventName eventT, SourceT& source);

    virtual void callbackReady(EventName event, std::function<void()> callback);

    ~EventListener();

    //bool operator< (const EventListener& x);
};


/*
 * Implementations for EventListener
 */
template <class Child>
EventListener<Child>::EventListener() {}
template <class Child>
// WARNING Since WithUuid is a *virtual* base class of GenericEventListener
// the WithUuid constructor will *not* be called if you subclass EventListener
// and call EventListener(uuid) in your initialization list.
// You'll have to *also* call WithUuid(uuid).
EventListener<Child>::EventListener(boost::uuids::uuid uuid) : WithUuid(uuid) {}

// FIXME Remove code duplication. I don't know how.

// Listener wants argument by reference
template <class Child>
template <typename SourceT, typename ArgT>
void EventListener<Child>::listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&, ArgT&)) {

  auto run_callback = [this,callback,event,&source](boost::any arg) { 
    if (arg.empty()) {
      std::cerr << "Event trigger typing error: the event was triggered without an argument yet the callback expects one.";
    } else {
      try {
        auto closure = std::bind(callback, static_cast<Child*>(this) ,std::ref(source), boost::any_cast<reference<ArgT>>(arg));
        (static_cast<Child*>(this))->callbackReady(event, closure);
      } catch (boost::bad_any_cast& e) {
        std::cerr << "Event trigger typing error: the event argument type and one of the callback types are incompatible" << std::endl;
      }
    }
  };

  EventManager::listen(event, source, *this, run_callback);
};

// Listener wants argument by value
template <class Child>
template <typename SourceT, typename ArgT>
void EventListener<Child>::listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&, ArgT)) {

  auto run_callback = [this,callback,event,&source](boost::any arg) { 
    if (arg.empty()) {
      std::cerr << "Event trigger typing error: the event was triggered without an argument yet the callback expects one.";
    } else {
      try {
        auto closure = std::bind(callback, static_cast<Child*>(this), std::ref(source), boost::any_cast<ArgT>(arg));
        (static_cast<Child*>(this))->callbackReady(event, closure);
      } catch (boost::bad_any_cast& e) {
        std::cerr << "Event trigger typing error: the event argument type and one of the callback types are incompatible" << std::endl;
      }
    }
  };

  EventManager::listen(event, source, *this, run_callback);
};

template <class Child>
template <typename SourceT>
void EventListener<Child>::listen(EventName event, SourceT& source, void (Child::*callback)(SourceT&)) {

  auto run_callback = [this,callback,event,&source](boost::any arg) { 
    std::bind(callback, static_cast<Child*>(this) ,std::ref(source))();
  };

  EventManager::listen(event, source, *this, run_callback);
};

template <class Child>
template <typename SourceT>
void EventListener<Child>::unlisten(EventName eventT, SourceT& source) {
  EventManager::unlisten(eventT, source, *this);
};

/* An event callback is ready to be called.
 * By default, this trivially executes the callback. Overload it in derived classes to do 
 * conditional triggering, event queues, etc... */
template <class Child>
void EventListener<Child>::callbackReady(EventName event, std::function<void()> callback) {
  callback();
}

template <class Child>
EventListener<Child>::~EventListener() {
  EventManager::unlisten(*this);
}


#endif // EVENT_LISTENER_H
