#ifndef EVENT_LISTENER_H
#define EVENT_LISTENER_H

#include "withUuid.h"
#include "eventManager.h"

/**
 * @brief EventListeners may subscribe to events generated by the Simulation
 */

// Make parent (EventListener) class aware of any of its subclasses. 
// The only purpose of this is to free the programmer from having to write:
// subscribe(this, T target, [] { ... callback ... })
// instead, they can just write:
// subscribe(T target, [] { ... callback ... })
// You must inherit from EventManager like so : class C : EventManager<C> { ... }
// otherwise, some totally unsafe casts will happen.
template <class Child>
class EventListener : public GenericEventListener {

public :
    void trigger(EventName event, std::function<void()> closure);
 	 /**
     * @brief subscribe to events of type eventT on target using callback
     * @param eventT: type of event being subscribed to (can be empty)
     * @param target: object the event is about
     * @param callback: a method of the instance inheriting from EventListener 
    */
    template <typename TargetT, typename ArgT>
    void subscribe(EventName event, TargetT& target, void (Child::*callback)(TargetT&, ArgT&));
    template <typename TargetT>
    void subscribe(EventName event, TargetT& target, void (Child::*callback)(TargetT&));

    /**
     * @brief unsubscribe to events of type eventT on target
     */
    template <typename TargetT>
    void unsubscribe(EventName eventT, TargetT& target);


    //bool operator< (const EventListener& x);
};


/*
 * Implementations for EventListener
 */

template <class Child>
template <typename TargetT, typename ArgT>
void EventListener<Child>::subscribe(EventName event, TargetT& target, void (Child::*callback)(TargetT&, ArgT&)) {

  auto run_callback = [this,callback,event,&target](boost::any arg) { 
    if (arg.empty()) {
      std::cerr << "Event trigger typing error: the event was triggered without an argument yet the callback expects one.";
    } else {
      try {
        auto closure = std::bind(callback, static_cast<Child*>(this) ,std::ref(target), boost::any_cast<reference<ArgT>>(arg));
        (static_cast<Child*>(this))->trigger(event, closure);
      } catch (boost::bad_any_cast& e) {
        std::cerr << "Event trigger typing error: the event argument type and one of the callback types are incompatible" << std::endl;
      }
    }
  };

  EventManager::subscribe(event, target, *this, run_callback);
};

template <class Child>
template <typename TargetT>
void EventListener<Child>::subscribe(EventName event, TargetT& target, void (Child::*callback)(TargetT&)) {

  auto run_callback = [this,callback,event,&target](boost::any arg) { 
    std::bind(callback, static_cast<Child*>(this) ,std::ref(target))();
  };

  EventManager::subscribe(event, target, *this, run_callback);
};

template <class Child>
template <typename TargetT>
void EventListener<Child>::unsubscribe(EventName eventT, TargetT& target) {
  EventManager::unsubscribe(eventT, target, *this);
};


template <class Child>
void EventListener<Child>::trigger(EventName event, std::function<void()> closure) {
  closure();
}

#endif // EVENT_LISTENER_H
